<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Práctica 1</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h2 id="práctica-1">Práctica 1</h2>
<p><strong>Ejercicio 1 ⋆</strong></p>
<p>Considerar las siguientes definiciones de funciones:</p>
<ul>
<li>
<p><code>max2 (x, y) | x &gt;= y = x | otherwise = y</code></p>
</li>
<li>
<p><code>normaVectorial (x, y) = sqrt (x^2 + y^2)</code></p>
</li>
<li>
<p><code>subtract = flip (-)</code></p>
</li>
<li>
<p><code>predecesor = subtract 1</code></p>
</li>
<li>
<p><code>evaluarEnCero = \f -&gt; f 0</code></p>
</li>
<li>
<p><code>dosVeces = \f -&gt; f . f</code></p>
</li>
<li>
<p><code>flipAll = map flip</code></p>
</li>
<li>
<p><code>flipRaro = flip flip</code></p>
</li>
</ul>
<p>i. ¿Cuál es el tipo de cada función? (Suponer que todos los números son de tipo <code>Float</code>).</p>
<ul>
<li><code>max2 :: (Float, Float) -&gt; Float</code></li>
<li><code>normaVectorial :: (Float, Float) -&gt; Float</code></li>
<li><code>subtract :: Float -&gt; Float -&gt; Float</code></li>
<li><code>predecesor :: Float -&gt; Float</code></li>
<li><code>evaluarEnCero :: (Float -&gt; a) -&gt; a</code></li>
<li><code>dosVeces :: (a -&gt; a) -&gt; (a -&gt; a)</code></li>
<li><code>flipAll :: [a -&gt; b -&gt; c] -&gt; [b -&gt; a -&gt; c]</code></li>
<li><code>flipRaro :: b -&gt; (a -&gt; b -&gt; c) -&gt; a -&gt; c</code></li>
</ul>
<p>ii. Indicar cuáles de las funciones anteriores no están currificadas. Para cada una de ellas, definir la función currificada correspondiente. Recordar dar el tipo de la función.</p>
<p>Las funciones que no están currificadas son <code>max2</code> y <code>normaVectorial</code>.</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token hvariable">max2Curry</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">max2Curry</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&gt;=</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token hvariable">y</span>
</code></pre>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token hvariable">normaVectorialCurry</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">normaVectorialCurry</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token builtin">sqrt</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">^</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token hvariable">y</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span>
</code></pre>
<hr>
<p><strong>Ejercicio 2 ⋆</strong></p>
<p>i. Definir la función <code>curry</code>, que dada una función de dos argumentos, devuelve su equivalente currificada.</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token builtin">curry</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span>
<span class="token builtin">curry</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
</code></pre>
<p>ii. Definir la función <code>uncurry</code>, que dada una función currificada de dos argumentos, devuelve su versión no currificada equivalente. Es la inversa de la anterior.</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token builtin">uncurry</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span>
<span class="token builtin">uncurry</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span>
</code></pre>
<p>iii. ¿Se podría definir una función <code>curryN</code>, que tome una función de un número arbitrario de argumentos y devuelva su versión currificada?<br>
<strong>Sugerencia</strong>: pensar cuál sería el tipo de la función.</p>
<p>No, no se podría, ya que el número de argumentos de una función está codificado en su tipo. Una función que toma dos argumentos tiene un tipo diferente a una que toma tres, y así sucesivamente.</p>
<hr>
<p><strong>Ejercicio 3 ⋆</strong></p>
<p>i. Redefinir usando <code>foldr</code> las funciones <code>sum</code>, <code>elem</code>, <code>(++)</code>, <code>filter</code> y <code>map</code>.</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token builtin">sum</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Float</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token number">0</span>
</code></pre>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token builtin">elem</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token builtin">elem</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">el</span> <span class="token hvariable">rec</span> <span class="token operator">-&gt;</span> <span class="token hvariable">el</span> <span class="token operator">==</span> <span class="token hvariable">x</span> <span class="token operator">||</span> <span class="token hvariable">rec</span><span class="token punctuation">)</span> <span class="token constant">False</span>
</code></pre>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token hvariable">xs</span> <span class="token hvariable">ys</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">)</span> <span class="token hvariable">ys</span> <span class="token hvariable">xs</span>
</code></pre>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token builtin">filter</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token builtin">filter</span> <span class="token hvariable">p</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">rec</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token hvariable">p</span> <span class="token hvariable">x</span> <span class="token keyword">then</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token hvariable">rec</span> <span class="token keyword">else</span> <span class="token hvariable">rec</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code></pre>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token builtin">map</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span>
<span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">rec</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token hvariable">rec</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code></pre>
<p>ii. Definir la función <code>mejorSegún :: (a -&gt; a -&gt; Bool) -&gt; [a] -&gt; a</code>, que devuelve el máximo elemento de la lista según una función de comparación, utilizando <code>foldr1</code>.<br>
Por ejemplo, <code>maximum = mejorSegún (&gt;)</code>.</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token hvariable">mejorSegun</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">mejorSegun</span> <span class="token hvariable">cmp</span> <span class="token operator">=</span> <span class="token builtin">foldr1</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">rec</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token hvariable">cmp</span> <span class="token hvariable">x</span> <span class="token hvariable">rec</span> <span class="token keyword">then</span> <span class="token hvariable">x</span> <span class="token keyword">else</span> <span class="token hvariable">rec</span><span class="token punctuation">)</span>
</code></pre>
<p>iii. Definir la función <code>sumasParciales :: Num a =&gt; [a] -&gt; [a]</code>, que dada una lista de números devuelve otra de la misma longitud, que tiene en cada posición la suma parcial de los elementos de la lista original desde la cabeza hasta la posición actual.<br>
Por ejemplo, <code>sumasParciales [1,4,-1,0,5] = [1,5,4,4,9]</code>.</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token hvariable">sumasParciales</span> <span class="token operator">::</span> <span class="token constant">Num</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">sumasParciales</span> <span class="token operator">=</span> <span class="token builtin">foldl</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">acc</span> <span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">acc</span> <span class="token operator">++</span> <span class="token keyword">if</span> <span class="token builtin">null</span> <span class="token hvariable">acc</span> <span class="token keyword">then</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token punctuation">[</span><span class="token builtin">last</span> <span class="token hvariable">acc</span> <span class="token operator">+</span> <span class="token hvariable">x</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code></pre>
<p>iv. Definir la función <code>sumaAlt</code>, que realiza la suma alternada de los elementos de una lista. Es decir, da como resultado: el primer elemento, menos el segundo, más el tercero, menos el cuarto, etc. Usar <code>foldr</code>.</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token hvariable">sumaAlt</span> <span class="token operator">::</span> <span class="token constant">Num</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">sumaAlt</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token punctuation">)</span> <span class="token number">0</span>
</code></pre>
<p>v. Hacer lo mismo que en el punto anterior, pero en sentido inverso (el último elemento menos el anteúltimo, etc.). Pensar qué esquema de recursión conviene usar en este caso.</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token hvariable">sumaAlt</span> <span class="token operator">::</span> <span class="token constant">Num</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">sumaAlt</span> <span class="token operator">=</span> <span class="token builtin">foldl</span> <span class="token punctuation">(</span><span class="token builtin">flip</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">0</span>
</code></pre>
<hr>
<p><strong>Ejercicio 4</strong></p>
<p>i. Definir la función <code>permutaciones :: [a] -&gt; [[a]]</code>, que dada una lista devuelve todas sus permutaciones. Se recomienda utilizar <code>concatMap :: (a -&gt; [b]) -&gt; [a] -&gt; [b]</code>, y también <code>take</code> y <code>drop</code>.</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token hvariable">permutaciones</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">permutaciones</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">rec</span> <span class="token operator">-&gt;</span> <span class="token builtin">concatMap</span> <span class="token punctuation">(</span><span class="token hvariable">insertar</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token hvariable">rec</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
	<span class="token keyword">where</span>
		<span class="token hvariable">insertar</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
		<span class="token hvariable">insertar</span> <span class="token hvariable">x</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">take</span> <span class="token hvariable">i</span> <span class="token hvariable">xs</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token builtin">drop</span> <span class="token hvariable">i</span> <span class="token hvariable">xs</span> <span class="token operator">|</span> <span class="token hvariable">i</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">..</span><span class="token builtin">length</span> <span class="token hvariable">xs</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre>
<p>ii. Definir la función <code>partes</code>, que recibe una lista <code>L</code> y devuelve la lista de todas las listas formadas por los mismos elementos de <code>L</code>, en su mismo orden de aparición.<br>
Ejemplo: <code>partes [5, 1, 2] → [[], [5], [1], [2], [5, 1], [5, 2], [1, 2], [5, 1, 2]]</code> (en algún orden).</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token hvariable">partes</span><span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">partes</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">rec</span> <span class="token operator">-&gt;</span> <span class="token hvariable">rec</span> <span class="token operator">++</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token punctuation">)</span> <span class="token hvariable">rec</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre>
<p>iii. Definir la función <code>prefijos</code>, que dada una lista, devuelve todos sus prefijos.<br>
Ejemplo: <code>prefijos [5, 1, 2] → [[], [5], [5, 1], [5, 1, 2]]</code>.</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token hvariable">prefijos</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">prefijos</span> <span class="token operator">=</span> <span class="token builtin">foldl</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">acc</span> <span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">acc</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token builtin">last</span> <span class="token hvariable">acc</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre>
<p>iv. Definir la función <code>sublistas</code>, que dada una lista, devuelve todas sus sublistas (listas de elementos que aparecen consecutivos en la lista original).<br>
Ejemplo: <code>sublistas [5, 1, 2] → [[], [5], [1], [2], [5, 1], [1, 2], [5, 1, 2]]</code> (en algún orden).</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token hvariable">sublistas</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">sublistas</span> <span class="token operator">=</span> <span class="token hvariable">recr</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">xs</span> <span class="token hvariable">rec</span> <span class="token operator">-&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">prefijos</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">++</span> <span class="token hvariable">rec</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>

<span class="token hvariable">recr</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span>
<span class="token hvariable">recr</span> <span class="token hvariable">_</span> <span class="token hvariable">z</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token hvariable">z</span>
<span class="token hvariable">recr</span> <span class="token hvariable">f</span> <span class="token hvariable">z</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token hvariable">xs</span> <span class="token punctuation">(</span><span class="token hvariable">recr</span> <span class="token hvariable">f</span> <span class="token hvariable">z</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code></pre>
<hr>
<p><strong>Ejercicio 5 ⋆</strong></p>
<p>Considerar las siguientes funciones:</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token hvariable">elementosEnPosicionesPares</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">elementosEnPosicionesPares</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token hvariable">elementosEnPosicionesPares</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token builtin">null</span> <span class="token hvariable">xs</span>
    <span class="token keyword">then</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span>
    <span class="token keyword">else</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token hvariable">elementosEnPosicionesPares</span> <span class="token punctuation">(</span><span class="token builtin">tail</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>

<span class="token hvariable">entrelazar</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">entrelazar</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">id</span>
<span class="token hvariable">entrelazar</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">ys</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token builtin">null</span> <span class="token hvariable">ys</span>
    <span class="token keyword">then</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token hvariable">entrelazar</span> <span class="token hvariable">xs</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">else</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token builtin">head</span> <span class="token hvariable">ys</span> <span class="token operator">:</span> <span class="token hvariable">entrelazar</span> <span class="token hvariable">xs</span> <span class="token punctuation">(</span><span class="token builtin">tail</span> <span class="token hvariable">ys</span><span class="token punctuation">)</span>
</code></pre>
<p>Indicar si la recursión utilizada en cada una de ellas es o no estructural. Si lo es, reescribirla utilizando <code>foldr</code>. En caso contrario, explicar el motivo.</p>
<ul>
<li><code>elementosEnPosicionesPares</code> no utiliza recursión estructural, ya que la función se vuelve a llamar con <code>tail xs</code> y no con <code>xs</code>.</li>
<li><code>entrelazar</code> si utiliza recursión estructural. Su versión con foldr sería:</li>
</ul>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token hvariable">entrelazar</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">entrelazar</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">rec</span> <span class="token hvariable">ys</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token builtin">null</span> <span class="token hvariable">ys</span>
	<span class="token keyword">then</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token hvariable">rec</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
	<span class="token keyword">else</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token builtin">head</span> <span class="token hvariable">ys</span> <span class="token operator">:</span> <span class="token hvariable">rec</span> <span class="token punctuation">(</span><span class="token builtin">tail</span> <span class="token hvariable">ys</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token builtin">id</span>
</code></pre>
<hr>
<p><strong>Ejercicio 6 ⋆</strong></p>
<p>El siguiente esquema captura la recursión primitiva sobre listas.</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token hvariable">recr</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span>
<span class="token hvariable">recr</span> <span class="token hvariable">_</span> <span class="token hvariable">z</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token hvariable">z</span>
<span class="token hvariable">recr</span> <span class="token hvariable">f</span> <span class="token hvariable">z</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token hvariable">xs</span> <span class="token punctuation">(</span><span class="token hvariable">recr</span> <span class="token hvariable">f</span> <span class="token hvariable">z</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code></pre>
<p>a. Definir la función <code>sacarUna :: Eq a =&gt; a -&gt; [a] -&gt; [a]</code>, que dados un elemento y una lista devuelve el resultado de eliminar de la lista la primera aparición del elemento (si está presente).</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token hvariable">sacarUna</span> <span class="token operator">::</span> <span class="token constant">Eq</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">sacarUna</span> <span class="token hvariable">el</span> <span class="token operator">=</span> <span class="token hvariable">recr</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">xs</span> <span class="token hvariable">rec</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">el</span> <span class="token keyword">then</span> <span class="token hvariable">xs</span> <span class="token keyword">else</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token hvariable">rec</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code></pre>
<p>b. Explicar por qué el esquema de recursión estructural (<code>foldr</code>) no es adecuado para implementar la función <code>sacarUna</code> del punto anterior.</p>
<p>No es el adecuado porque no tenemos manera de cortar la recursión al encontrar una aparición. Por ejemplo, si hubiera más de una aparición del elemento, con <code>foldr</code> eliminaríamos todas las apariciones.</p>
<p>c. Definir la función <code>insertarOrdenado :: Ord a =&gt; a -&gt; [a] -&gt; [a]</code> que inserta un elemento en una lista ordenada (de manera creciente), de manera que se preserva el ordenamiento.</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token hvariable">insertarOrdenado</span> <span class="token operator">::</span> <span class="token constant">Ord</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">insertarOrdenado</span> <span class="token hvariable">el</span> <span class="token operator">=</span> <span class="token hvariable">recr</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">xs</span> <span class="token hvariable">rec</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token hvariable">el</span> <span class="token keyword">then</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token hvariable">rec</span> <span class="token keyword">else</span> <span class="token hvariable">el</span> <span class="token operator">:</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token hvariable">el</span><span class="token punctuation">]</span>
</code></pre>
<hr>
<p><strong>Ejercicio 7 ⋆</strong></p>
<p>Definir las siguientes funciones para trabajar sobre listas, y dar su tipo. Todas ellas deben poder aplicarse a listas finitas e infinitas.</p>
<p>i. <code>mapPares</code>, una versión de <code>map</code> que toma una función currificada de dos argumentos y una lista de pares de valores, y devuelve la lista de aplicaciones de la función a cada par.<br>
Pista: recordar <code>curry</code> y <code>uncurry</code>.</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token hvariable">mapPares</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">c</span><span class="token punctuation">]</span>
<span class="token hvariable">mapPares</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token builtin">uncurry</span> <span class="token hvariable">f</span><span class="token punctuation">)</span>
</code></pre>
<p>ii. <code>armarPares</code>, que dadas dos listas arma una lista de pares que contiene, en cada posición, el elemento correspondiente a esa posición en cada una de las listas. Si una de las listas es más larga que la otra, ignorar los elementos que sobran (el resultado tendrá la longitud de la lista más corta).<br>
Esta función en Haskell se llama <code>zip</code>. Pista: aprovechar la currificación y utilizar evaluación parcial.</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token hvariable">armarPares</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">armarPares</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">rec</span> <span class="token hvariable">ys</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token builtin">null</span> <span class="token hvariable">ys</span> <span class="token keyword">then</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token builtin">head</span> <span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token hvariable">rec</span> <span class="token punctuation">(</span><span class="token builtin">tail</span> <span class="token hvariable">ys</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">const</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre>
<p>iii. <code>mapDoble</code>, una variante de <code>mapPares</code>, que toma una función currificada de dos argumentos y dos listas (de igual longitud), y devuelve una lista de aplicaciones de la función a cada elemento correspondiente de las dos listas.<br>
Esta función en Haskell se llama <code>zipWith</code>.</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token hvariable">mapDoble</span><span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">c</span><span class="token punctuation">]</span>
<span class="token hvariable">mapDoble</span> <span class="token hvariable">f</span> <span class="token hvariable">xs</span> <span class="token hvariable">ys</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token builtin">uncurry</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">armarPares</span> <span class="token hvariable">xs</span> <span class="token hvariable">ys</span><span class="token punctuation">)</span>
</code></pre>
<hr>
<p><strong>Ejercicio 8</strong></p>
<p>i. Escribir la función <code>sumaMat</code>, que representa la suma de matrices, usando <code>zipWith</code>.<br>
Representaremos una matriz como la lista de sus filas. Esto quiere decir que cada matriz será una lista finita de listas finitas, todas de la misma longitud, con elementos enteros.<br>
Recordamos que la suma de matrices se define como la suma celda a celda. Asumir que las dos matrices a sumar están bien formadas y tienen las mismas dimensiones.</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token hvariable">sumaMat</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">sumaMat</span> <span class="token operator">=</span> <span class="token builtin">zipWith</span> <span class="token punctuation">(</span><span class="token builtin">zipWith</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
<p>ii. Escribir la función <code>trasponer</code>, que, dada una matriz como las del ítem i, devuelva su traspuesta.<br>
Es decir, en la posición <code>i, j</code> del resultado está el contenido de la posición <code>j, i</code> de la matriz original.<br>
Notar que si la entrada es una lista de N listas, todas de longitud M, la salida debe tener M listas, todas de longitud N.</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token hvariable">trasponer</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">trasponer</span> <span class="token hvariable">m</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">xs</span> <span class="token hvariable">rec</span> <span class="token operator">-&gt;</span> <span class="token builtin">zipWith</span> <span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">)</span> <span class="token hvariable">xs</span> <span class="token hvariable">rec</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">replicate</span> <span class="token punctuation">(</span><span class="token builtin">length</span> <span class="token punctuation">(</span><span class="token builtin">head</span> <span class="token hvariable">m</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token hvariable">m</span>
</code></pre>
<hr>
<p>Aquí tienes los enunciados que mencionas copiados para ti:</p>
<hr>
<p><strong>Ejercicio 9 ⋆</strong></p>
<p>i. Definir y dar el tipo del esquema de recursión <code>foldNat</code> sobre los naturales. Utilizar el tipo <code>Integer</code> de Haskell (la función va a estar definida sólo para los enteros mayores o iguales que 0).</p>
<p>ii. Utilizando <code>foldNat</code>, definir la función <code>potencia</code>.</p>
<hr>
<p><strong>Ejercicio 10</strong></p>
<p>i. Definir la función <code>genLista :: a -&gt; (a -&gt; a) -&gt; Integer -&gt; [a]</code>, que genera una lista de una cantidad dada de elementos, a partir de un elemento inicial y de una función de incremento entre los elementos de la lista. Dicha función de incremento, dado un elemento de la lista, devuelve el elemento siguiente.</p>
<p>ii. Usando <code>genLista</code>, definir la función <code>desdeHasta</code>, que dado un par de números (el primero menor que el segundo), devuelve una lista de números consecutivos desde el primero hasta el segundo.</p>
<hr>
<p><strong>Ejercicio 11</strong></p>
<p>Definir el esquema de recursión estructural para el siguiente tipo:</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token keyword">data</span> <span class="token constant">Polinomio</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">X</span>
                 <span class="token operator">|</span> <span class="token constant">Cte</span> <span class="token hvariable">a</span>
                 <span class="token operator">|</span> <span class="token constant">Suma</span> <span class="token punctuation">(</span><span class="token constant">Polinomio</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Polinomio</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
                 <span class="token operator">|</span> <span class="token constant">Prod</span> <span class="token punctuation">(</span><span class="token constant">Polinomio</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Polinomio</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
</code></pre>
<p>Luego usar el esquema definido para escribir la función <code>evaluar :: Num a =&gt; a -&gt; Polinomio a -&gt; a</code> que, dado un número y un polinomio, devuelve el resultado de evaluar el polinomio dado en el número dado.</p>
<hr>
<p><strong>Ejercicio 12 ⋆</strong></p>
<p>Considerar el siguiente tipo, que representa a los árboles binarios:</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token keyword">data</span> <span class="token constant">AB</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Nil</span> <span class="token operator">|</span> <span class="token constant">Bin</span> <span class="token punctuation">(</span><span class="token constant">AB</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token constant">AB</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
</code></pre>
<p>i. Usando recursión explícita, definir los esquemas de recursión estructural (<code>foldAB</code>) y primitiva (<code>recAB</code>), y dar sus tipos.</p>
<p>ii. Definir las funciones <code>esNil</code>, <code>altura</code> y <code>cantNodos</code> (para <code>esNil</code> puede utilizarse <code>case</code> en lugar de <code>foldAB</code> o <code>recAB</code>).</p>
<p>iii. Definir la función <code>mejorSegún :: (a -&gt; a -&gt; Bool) -&gt; AB a -&gt; a</code>, análoga a la del ejercicio 3, para árboles. Se recomienda definir una función auxiliar para comparar la raíz con un posible resultado de la recursión para un árbol que puede o no ser <code>Nil</code>.</p>
<p>iv. Definir la función <code>esABB :: Ord a =&gt; AB a -&gt; Bool</code> que chequea si un árbol es un árbol binario de búsqueda. Recordar que, en un árbol binario de búsqueda, el valor de un nodo es mayor o igual que los valores que aparecen en el subárbol izquierdo y es estrictamente menor que los valores que aparecen en el subárbol derecho.</p>
<p>v. Justificar la elección de los esquemas de recursión utilizados para los tres puntos anteriores.</p>
<hr>
<p><strong>Ejercicio 13</strong></p>
<p>Dado el tipo <code>AB a</code> del ejercicio 12:</p>
<p>i. Definir las funciones <code>ramas</code> (caminos desde la raíz hasta las hojas), <code>cantHojas</code> y <code>espejo</code>.</p>
<p>ii. Definir la función <code>mismaEstructura :: AB a -&gt; AB b -&gt; Bool</code> que, dados dos árboles, indica si éstos tienen la misma forma, independientemente del contenido de sus nodos. Pista: usar evaluación parcial y recordar el ejercicio 7.</p>
<hr>
<p><strong>Ejercicio 14</strong></p>
<p>Se desea modelar en Haskell los árboles con información en las hojas (y sólo en ellas). Para esto introduciremos el siguiente tipo:</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token keyword">data</span> <span class="token constant">AIH</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Hoja</span> <span class="token hvariable">a</span> <span class="token operator">|</span> <span class="token constant">Bin</span> <span class="token punctuation">(</span><span class="token constant">AIH</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">AIH</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
</code></pre>
<p>a) Definir el esquema de recursión estructural <code>foldAIH</code> y dar su tipo. Por tratarse del primer esquema de recursión que tenemos para este tipo, se permite usar recursión explícita.</p>
<p>b) Escribir las funciones <code>altura :: AIH a -&gt; Integer</code> y <code>tamaño :: AIH a -&gt; Integer</code>. Considerar que la altura de una hoja es 1 y el tamaño de un <code>AIH</code> es su cantidad de hojas.</p>
<hr>
<p><strong>Ejercicio 15 ⋆</strong></p>
<p>i. Definir el tipo <code>RoseTree</code> de árboles no vacíos, con una cantidad indeterminada de hijos para cada nodo.</p>
<p>ii. Escribir el esquema de recursión estructural para <code>RoseTree</code>. Importante escribir primero su tipo.</p>
<p>iii. Usando el esquema definido, escribir las siguientes funciones:</p>
<ul>
<li>
<p>a) <code>hojas</code>, que dado un <code>RoseTree</code>, devuelva una lista con sus hojas ordenadas de izquierda a derecha, según su aparición en el <code>RoseTree</code>.</p>
</li>
<li>
<p>b) <code>distancias</code>, que dado un <code>RoseTree</code>, devuelva las distancias de su raíz a cada una de sus hojas.</p>
</li>
<li>
<p>c) <code>altura</code>, que devuelve la altura de un <code>RoseTree</code> (la cantidad de nodos de la rama más larga). Si el <code>RoseTree</code> es una hoja, se considera que su altura es 1.</p>
</li>
</ul>
<hr>
<p><strong>Ejercicio 16</strong> <em>(Opcional)</em></p>
<p>Se desea representar conjuntos mediante Hashing abierto (chain addressing). El Hashing abierto consta de dos funciones: una función de Hash, que dado un elemento devuelve un valor entero (el cual se espera que no se repita con frecuencia), y una tabla de Hash, que dado un número entero devuelve los elementos del conjunto a los que la función de Hash asignó dicho número (es decir, la preimagen de la función de Hash para ese número).</p>
<p>Los representaremos en Haskell de la siguiente manera:</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token keyword">data</span> <span class="token constant">HashSet</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Hash</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Integer</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Integer</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre>
<p>Por contexto de uso, vamos a suponer que la tabla de Hash es una función total, que devuelve listas vacías para los números que no corresponden a elementos del conjunto. Este es un invariante que deberá preservarse en todas las funciones que devuelvan conjuntos.</p>
<p>Definir las siguientes funciones:</p>
<p>i. <code>vacío :: (a -&gt; Integer) -&gt; HashSet a</code>, que devuelve un conjunto vacío con la función de Hash indicada.</p>
<p>ii. <code>pertenece :: Eq a =&gt; a -&gt; HashSet a -&gt; Bool</code>, que indica si un elemento pertenece a un conjunto. Es decir, si se encuentra en la lista obtenida en la tabla de Hash para el número correspondiente a la función de Hash del elemento.</p>
<p>Por ejemplo:</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token hvariable">pertenece</span> <span class="token number">5</span> <span class="token operator">$</span> <span class="token hvariable">agregar</span> <span class="token number">1</span> <span class="token operator">$</span> <span class="token hvariable">agregar</span> <span class="token number">2</span> <span class="token operator">$</span> <span class="token hvariable">agregar</span> <span class="token number">1</span> <span class="token operator">$</span> <span class="token hvariable">vac</span>í<span class="token hvariable">o</span> <span class="token punctuation">(</span><span class="token builtin">flip</span> <span class="token builtin">mod</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token hvariable">devuelve</span> <span class="token constant">False</span><span class="token punctuation">.</span>
<span class="token hvariable">pertenece</span> <span class="token number">2</span> <span class="token operator">$</span> <span class="token hvariable">agregar</span> <span class="token number">1</span> <span class="token operator">$</span> <span class="token hvariable">agregar</span> <span class="token number">2</span> <span class="token operator">$</span> <span class="token hvariable">agregar</span> <span class="token number">1</span> <span class="token operator">$</span> <span class="token hvariable">vac</span>í<span class="token hvariable">o</span> <span class="token punctuation">(</span><span class="token builtin">flip</span> <span class="token builtin">mod</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token hvariable">devuelve</span> <span class="token constant">True</span><span class="token punctuation">.</span>
</code></pre>
<p>iii. <code>agregar :: Eq a =&gt; a -&gt; HashSet a -&gt; HashSet a</code>, que agrega un elemento a un conjunto. Si el elemento ya estaba en el conjunto, se debe devolver el conjunto sin modificaciones.</p>
<p>iv. <code>intersección :: Eq a =&gt; HashSet a -&gt; HashSet a -&gt; HashSet a</code> que, dados dos conjuntos, devuelve un conjunto con la misma función de Hash del primero y con los elementos que pertenecen a ambos conjuntos a la vez.</p>
<p>v. <code>foldr1</code> (no relacionada con los conjuntos). Dar el tipo y definir la función <code>foldr1</code> para listas sin usar recursión explícita, recurriendo a alguno de los esquemas de recursión conocidos. Se recomienda usar la función <code>error :: String -&gt; a</code> para el caso de la lista vacía.</p>
<hr>
<p><strong>Ejercicio 17</strong></p>
<p>¿Cuál es el valor de esta expresión?</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token punctuation">[</span> <span class="token hvariable">x</span> <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">y</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token operator">..</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token hvariable">y</span><span class="token punctuation">)</span> `<span class="token builtin">mod</span>'` <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">]</span>
</code></pre>
<hr>
<p><strong>Ejercicio 18</strong></p>
<p>Definir la lista infinita <code>paresDeNat :: [(Int, Int)]</code>, que contenga todos los pares de números naturales: <code>(0,0)</code>, <code>(0,1)</code>, <code>(1,0)</code>, etc.</p>
<hr>
<p><strong>Ejercicio 19</strong></p>
<p>Una tripla pitagórica es una tripla <code>(a, b, c)</code> de enteros positivos tal que <code>a^2 + b^2 = c^2</code>.</p>
<p>La siguiente expresión intenta ser una definición de una lista (infinita) de triplas pitagóricas:</p>
<pre class=" language-haskell"><code class="prism  language-haskell"><span class="token hvariable">pitag</span>ó<span class="token hvariable">ricas</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">Integer</span><span class="token punctuation">,</span> <span class="token constant">Integer</span><span class="token punctuation">,</span> <span class="token constant">Integer</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">pitag</span>ó<span class="token hvariable">ricas</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">b</span> <span class="token operator">&lt;-</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">c</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token operator">^</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token hvariable">b</span><span class="token operator">^</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token hvariable">c</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">]</span>
</code></pre>
<p>Explicar por qué esta definición no es útil. Dar una definición mejor.</p>
<hr>
<p><strong>Ejercicio 20</strong></p>
<p>Escribir la función <code>listasQueSuman :: Int -&gt; [[Int]]</code> que, dado un número natural <code>n</code>, devuelve todas las listas de enteros positivos (es decir, mayores o iguales que 1) cuya suma sea <code>n</code>. Para este ejercicio se permite usar recursión explícita. Pensar por qué la recursión utilizada no es estructural.</p>
<p>(Este ejercicio no es de generación infinita, pero puede ser útil para otras funciones que generen listas infinitas de listas).</p>
<hr>
<p><strong>Ejercicio 21</strong></p>
<p>Definir en Haskell una lista que contenga todas las listas finitas de enteros positivos (esto es, con elementos mayores o iguales que 1).</p>
<hr>
<p><strong>Ejercicio 22</strong></p>
<p>Dado el tipo de datos <code>AIH a</code> definido en el ejercicio 14:</p>
<p>a) Definir la lista (infinita) de todos los <code>AIH</code> cuyas hojas tienen tipo <code>()</code>. Se recomienda definir una función auxiliar. Para este ejercicio se permite utilizar recursión explícita.</p>
<p>b) Explicar por qué la recursión utilizada en el punto a) no es estructural.</p>
<hr>
</div>
</body>

</html>
